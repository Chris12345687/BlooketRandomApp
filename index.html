<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Blooket Program</title>

<!-- PWA setup -->
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#2196f3">
<link rel="apple-touch-icon" href="icons/icon-192.png">

<style>
body { font-family: Arial, sans-serif; background: #f3f3f3; margin: 0; padding: 20px; }
h1 { color: #333; }
label { display: block; margin-top: 10px; font-weight: bold; }
input[type=text], textarea { width: 100%; padding: 5px; font-family: monospace; }
button { margin: 5px 2px; padding: 10px; font-weight: bold; border: none; cursor: pointer; }
.add { background: #4caf50; color: white; }
.delete { background: #f44336; color: white; }
.save { background: #ff9800; color: white; }
.cancel { background: #9e9e9e; color: white; }
.export { background: #2196f3; color: white; }
.undo { background: #795548; color: white; }
.redo { background: #9c27b0; color: white; }
.download { background: #3f51b5; color: white; }
table { width: 100%; border-collapse: collapse; margin-top: 20px; }
th, td { border: 1px solid #ccc; padding: 5px; text-align: left; }
th { background: #eee; }
tr:hover { background: #fafafa; }
</style>
</head>
<body>

<h1>Blooket Program</h1>
<p>Manage your Blooket CSV questions. Works offline and on iPad. Add, edit, and download CSV files easily.</p>

<label>Prompt (for extracting questions from images):</label>
<textarea id="prompt" rows="10" readonly>
You will receive an image containing multiple-choice questions. For each question, extract the following data exactly as written — do not translate, fix, or change any text. Extract into these fields: question = the full question text A = answer choice A (remove the 'A.' label) B = answer choice B (remove the 'B.' label) C = answer choice C (remove the 'C.' label) D = answer choice D (remove the 'D.' label) Ans = the correct answer number (1 for A, 2 for B, 3 for C, 4 for D) — based on the circled answer in the image. Output the result in Python format, like this for each question: question = "" A = "" B = "" C = "" D = "" Ans = "" Do not translate, fix grammar, summarize, or modify any text. Just extract it exactly as it appears, using the circled answers for 'Ans'.
</textarea>
<button onclick="copyPrompt()">Copy Prompt</button>

<div style="margin-top:10px;">
<!-- File input (hidden) -->
<input type="file" id="fileInput" accept=".csv" style="display:none" onchange="handleFileSelect(event)">
<button onclick="triggerFileSelect()">Select CSV File</button>
<button onclick="loadFile()">Load CSV</button>
<button onclick="deselectFile()">Deselect File</button>
<button class="download" onclick="newCSV()">New CSV</button>
<button class="undo" onclick="undo()">Undo</button>
<button class="redo" onclick="redo()">Redo</button>
<span id="fileName">No file chosen</span>
</div>

<label>Question:</label>
<textarea id="question" rows="2"></textarea>
<label>A (Answer 1):</label><input type="text" id="A1">
<label>B (Answer 2):</label><input type="text" id="A2">
<label>C (Answer 3 - optional):</label><input type="text" id="A3">
<label>D (Answer 4 - optional):</label><input type="text" id="A4">
<label>Correct Answer(s) (1-4, comma-separated):</label><input type="text" id="correct">

<div>
<button class="add" onclick="addQuestion()">Add Question</button>
<button class="save" onclick="saveEdit()">Save Edit</button>
<button class="cancel" onclick="cancelEdit()">Cancel Edit</button>
<button class="export" onclick="downloadCSV()">Download CSV</button>
</div>

<table id="questionTable">
<thead>
<tr><th>#</th><th>Question</th><th>A1</th><th>A2</th><th>A3</th><th>A4</th><th>Time</th><th>Correct</th><th>Delete</th></tr>
</thead>
<tbody></tbody>
</table>

<script>
// Register service worker for PWA
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('service-worker.js')
    .then(() => console.log("Service Worker registered"))
    .catch(err => console.log("Service Worker failed", err));
}

let dataList = [];
let editingIndex = null;
let fileHandle = null;

// Undo / Redo
let undoStack = [];
let redoStack = [];
function pushUndo() { undoStack.push(JSON.stringify(dataList)); redoStack = []; }
function undo() { if (!undoStack.length) return alert("Nothing to undo"); redoStack.push(JSON.stringify(dataList)); dataList = JSON.parse(undoStack.pop()); renderTable(); }
function redo() { if (!redoStack.length) return alert("Nothing to redo"); undoStack.push(JSON.stringify(dataList)); dataList = JSON.parse(redoStack.pop()); renderTable(); }

// Prompt copy
function copyPrompt() {
  const t = document.getElementById("prompt");
  t.select();
  document.execCommand("copy");
  alert("Prompt copied!");
}

// --- File input handling ---
function triggerFileSelect() { document.getElementById('fileInput').click(); }
function handleFileSelect(event) {
  const file = event.target.files[0];
  if (!file) return;
  fileHandle = file;
  document.getElementById('fileName').textContent = file.name;
  const reader = new FileReader();
  reader.onload = e => {
    dataList = parseCSV(e.target.result);
    renderTable();
    alert("File loaded!");
  }
  reader.readAsText(file);
}

function deselectFile() {
  fileHandle = null;
  dataList = [];
  renderTable();
  clearInputs();
  document.getElementById('fileName').textContent = "No file chosen";
  alert("File deselected and cleared.");
}

// Load file button for compatibility
function loadFile() {
  if (!fileHandle) return alert("Select a CSV file first");
  const reader = new FileReader();
  reader.onload = e => {
    dataList = parseCSV(e.target.result);
    renderTable();
    alert("File loaded!");
  }
  reader.readAsText(fileHandle);
}

// Parse CSV
function parseCSV(text) {
  const lines = text.split("\n").slice(2);
  const data = [];
  for (const line of lines) {
    if (!line.trim()) continue;
    const row = [];
    let val = "", inQuotes = false;
    for (let i=0;i<line.length;i++){
      const c = line[i];
      if (c === '"' && line[i+1] === '"'){ val+='"'; i++; }
      else if (c === '"') inQuotes = !inQuotes;
      else if (c === ',' && !inQuotes){ row.push(val); val=""; }
      else val+=c;
    }
    row.push(val);
    data.push([row[1]||"",row[2]||"",row[3]||"",row[4]||"",row[5]||"",row[6]||"300",row[7]?.replace(/"/g,"")||""]);
  }
  return data;
}

// New CSV
function newCSV() {
  dataList=[];
  renderTable();
  const csv = makeCSV();
  downloadData(csv, "new_blooket.csv");
  alert("New CSV created!");
}

// Download CSV
function downloadCSV() {
  const csv = makeCSV();
  downloadData(csv, "blooket_export.csv");
  alert("CSV downloaded!");
}

function makeCSV() {
  let csv = "Blooket Import Template,,,,,,,\n";
  csv += "Question #,Question Text,Answer 1,Answer 2,Answer 3 (Optional),Answer 4 (Optional),Time Limit (sec) (Max: 300 seconds),Correct Answer(s)\n";
  dataList.forEach((r,i)=>{
    const escaped = r.map(f=>f?`"${f.replace(/"/g,'""')}"`:"");
    csv+=`${i+1},${escaped.join(",")}\n`;
  });
  return csv;
}

function downloadData(text, filename) {
  const blob = new Blob([text],{type:'text/csv'});
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
  URL.revokeObjectURL(link.href);
}

// Validation
function validateInputs(q,A1,A2,A3,A4,correct){
  correct = correct.replace(/\s/g,'');
  if(!q||!A1||!A2||!correct) return alert("Fill Question, A1, A2, Correct");
  const answers=[A1,A2,A3,A4].filter(a=>a);
  if(new Set(answers).size!==answers.length) return alert("Duplicate answers");
  if(!/^[1-4](,[1-4])*$/.test(correct)) return alert("Correct answers must be 1-4");
  return true;
}

// CRUD
function addQuestion(){
  if(editingIndex!==null) return alert("Editing active");
  let q=document.getElementById("question").value.trim();
  let A1=document.getElementById("A1").value.trim();
  let A2=document.getElementById("A2").value.trim();
  let A3=document.getElementById("A3").value.trim();
  let A4=document.getElementById("A4").value.trim();
  let correct=document.getElementById("correct").value.trim();
  if(!validateInputs(q,A1,A2,A3,A4,correct))return;
  pushUndo();
  dataList.push([q,A1,A2,A3,A4,"300",correct]);
  renderTable(); clearInputs();
}

function renderTable(){
  const tbody=document.querySelector("#questionTable tbody");
  tbody.innerHTML="";
  dataList.forEach((r,i)=>{
    const tr=document.createElement("tr");
    tr.innerHTML=`<td>${i+1}</td><td>${r[0]}</td><td>${r[1]}</td><td>${r[2]}</td><td>${r[3]}</td><td>${r[4]}</td><td>${r[5]}</td><td>${r[6]}</td>
    <td><button class='delete' onclick='deleteQuestion(${i});event.stopPropagation();'>Delete</button></td>`;
    tr.onclick=()=>editQuestion(i);
    tbody.appendChild(tr);
  });
}

function clearInputs(){["question","A1","A2","A3","A4","correct"].forEach(id=>document.getElementById(id).value=""); editingIndex=null;}
function deleteQuestion(i){pushUndo();dataList.splice(i,1);renderTable();clearInputs();}
function editQuestion(i){editingIndex=i;const r=dataList[i];["question","A1","A2","A3","A4"].forEach((id,idx)=>document.getElementById(id).value=r[idx]);document.getElementById("correct").value=r[6];}
function saveEdit(){if(editingIndex===null)return alert("No question edited");let q=document.getElementById("question").value.trim(),A1=document.getElementById("A1").value.trim(),A2=document.getElementById("A2").value.trim(),A3=document.getElementById("A3").value.trim(),A4=document.getElementById("A4").value.trim(),correct=document.getElementById("correct").value.trim();if(!validateInputs(q,A1,A2,A3,A4,correct))return;pushUndo();dataList[editingIndex]=[q,A1,A2,A3,A4,"300",correct];renderTable();clearInputs();}
function cancelEdit(){clearInputs();}
</script>

</body>
</html>
