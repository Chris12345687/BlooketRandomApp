<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Blooket Program</title>

<!-- Manifest + Theme -->
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#2196f3">
<link rel="apple-touch-icon" href="icons/icon-192.png">

<style>
body { font-family: Arial, sans-serif; background: #f3f3f3; margin: 0; padding: 20px; }
h1 { color: #333; }
label { display: block; margin-top: 10px; font-weight: bold; }
input[type=text], textarea { width: 100%; padding: 5px; font-family: monospace; }
button { margin: 5px 2px; padding: 10px; font-weight: bold; border: none; cursor: pointer; }
.add { background: #4caf50; color: white; }
.delete { background: #f44336; color: white; }
.save { background: #ff9800; color: white; }
.cancel { background: #9e9e9e; color: white; }
.export { background: #2196f3; color: white; }
.undo { background: #795548; color: white; }
.redo { background: #9c27b0; color: white; }
table { width: 100%; border-collapse: collapse; margin-top: 20px; }
th, td { border: 1px solid #ccc; padding: 5px; text-align: left; }
th { background: #eee; }
tr:hover { background: #fafafa; }
</style>
</head>
<body>

<h1>Blooket Program</h1>
<p>Manage your Blooket CSV questions. Load existing files, add new questions, and save/update CSV automatically.</p>

<label>Prompt (for extracting questions from images):</label>
<textarea id="prompt" rows="10" readonly>
You will receive an image containing multiple-choice questions. For each question, extract the following data exactly as written — do not translate, fix, or change any text. Extract into these fields: question = the full question text A = answer choice A (remove the 'A.' label) B = answer choice B (remove the 'B.' label) C = answer choice C (remove the 'C.' label) D = answer choice D (remove the 'D.' label) Ans = the correct answer number (1 for A, 2 for B, 3 for C, 4 for D) — based on the circled answer in the image. Output the result in Python format, like this for each question: question = "" A = "" B = "" C = "" D = "" Ans = "" Do not translate, fix grammar, summarize, or modify any text. Just extract it exactly as it appears, using the circled answers for 'Ans'.
</textarea>
<button onclick="copyPrompt()">Copy Prompt to Clipboard</button>

<div style="margin-top:10px;">
<button onclick="chooseFile()">Select CSV File</button>
<button onclick="loadFile()">Load Existing CSV</button>
<button onclick="deselectFile()">Deselect File</button>
<button onclick="newCSV()">New CSV</button>
<button class="undo" onclick="undo()">Undo</button>
<button class="redo" onclick="redo()">Redo</button>
<span id="fileName">No file chosen</span>
</div>

<label>Question:</label>
<textarea id="question" rows="2"></textarea>
<label>A (Answer 1):</label><input type="text" id="A1">
<label>B (Answer 2):</label><input type="text" id="A2">
<label>C (Answer 3 - optional):</label><input type="text" id="A3">
<label>D (Answer 4 - optional):</label><input type="text" id="A4">
<label>Correct Answer(s) (1-4, comma-separated):</label><input type="text" id="correct">

<div>
<button class="add" onclick="addQuestion()">Add Question</button>
<button class="save" onclick="saveEdit()">Save Edit</button>
<button class="cancel" onclick="cancelEdit()">Cancel Edit</button>
<button class="export" onclick="exportCSV()">Save / Update CSV</button>
</div>

<table id="questionTable">
<thead>
<tr><th>#</th><th>Question</th><th>A1</th><th>A2</th><th>A3</th><th>A4</th><th>Time</th><th>Correct</th><th>Delete</th></tr>
</thead>
<tbody></tbody>
</table>

<script>
// Register service worker for offline mode
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('service-worker.js')
    .then(() => console.log("Service Worker Registered"))
    .catch(err => console.log("SW registration failed", err));
}

let dataList = [];
let editingIndex = null;
let fileHandle = null;

// Undo / Redo stacks
let undoStack = [];
let redoStack = [];

function pushUndo() { undoStack.push(JSON.stringify(dataList)); redoStack = []; }
function undo() { if (!undoStack.length) return alert("Nothing to undo."); redoStack.push(JSON.stringify(dataList)); dataList = JSON.parse(undoStack.pop()); renderTable(); }
function redo() { if (!redoStack.length) return alert("Nothing to redo."); undoStack.push(JSON.stringify(dataList)); dataList = JSON.parse(redoStack.pop()); renderTable(); }

// Copy prompt
function copyPrompt() {
  const promptText = document.getElementById("prompt");
  promptText.select();
  document.execCommand("copy");
  alert("Prompt copied!");
}

// File picker
async function chooseFile() {
  try {
    [fileHandle] = await window.showOpenFilePicker({ types: [{ description: 'CSV File', accept: { 'text/csv': ['.csv'] } }] });
    document.getElementById('fileName').textContent = fileHandle.name;
  } catch(e) { console.log("File picker canceled"); }
}

// Deselect file
function deselectFile() {
  fileHandle = null;
  dataList = [];
  editingIndex = null;
  undoStack = [];
  redoStack = [];
  renderTable();
  clearInputs();
  document.getElementById('fileName').textContent = "No file chosen";
  alert("File deselected. Auto-save stopped and questions cleared.");
}

// New CSV
async function newCSV() {
  try {
    fileHandle = await window.showSaveFilePicker({
      suggestedName: "new_blooket.csv",
      types: [{ description: 'CSV File', accept: { 'text/csv': ['.csv'] } }]
    });
    dataList = [];
    editingIndex = null;
    undoStack = [];
    redoStack = [];
    renderTable();
    clearInputs();
    document.getElementById('fileName').textContent = fileHandle.name;
    await exportCSV();
    alert("New CSV file created and ready for editing!");
  } catch(e) {
    console.log("New CSV creation canceled", e);
    fileHandle = null;
  }
}

// Load CSV
async function loadFile() {
  if (!fileHandle) return alert("Select a file first");
  try {
    const file = await fileHandle.getFile();
    const text = await file.text();
    dataList = parseCSV(text);
    renderTable();
    clearInputs();
    alert("File loaded successfully!");
  } catch(e) { alert("Failed to load file: " + e); }
}

// Parse CSV
function parseCSV(text) {
  const lines = text.split("\n").slice(2);
  const data = [];
  for (let line of lines) {
    if (!line.trim()) continue;
    const row = [];
    let val = "", inQuotes = false;
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      if (char === '"' && line[i + 1] === '"') { val += '"'; i++; }
      else if (char === '"') inQuotes = !inQuotes;
      else if (char === ',' && !inQuotes) { row.push(val); val = ""; }
      else val += char;
    }
    row.push(val);
    data.push([row[1]||"", row[2]||"", row[3]||"", row[4]||"", row[5]||"", row[6]||"300", row[7]?.replace(/"/g,"")||""]);
  }
  return data;
}

// Export CSV
async function exportCSV() {
  if (!fileHandle) return alert("Select a file first");
  const writable = await fileHandle.createWritable();
  let csv = "Blooket Import Template,,,,,,,\n";
  csv += "Question #,Question Text,Answer 1,Answer 2,Answer 3 (Optional),Answer 4 (Optional),Time Limit (sec) (Max: 300 seconds),Correct Answer(s)\n";
  dataList.forEach((row, idx) => {
    let escaped = row.map(f => f ? `"${f.replace(/"/g,'""')}"` : "");
    csv += `${idx+1},${escaped.join(",")}\n`;
  });
  await writable.write(csv);
  await writable.close();
  console.log("CSV saved");
}

// Auto-save
setInterval(() => { if (fileHandle) exportCSV(); }, 5000);

// Validation
function validateInputs(q,A1,A2,A3,A4,correct){
  correct = correct.replace(/\s/g,'');
  if (!q||!A1||!A2||!correct) return alert("Fill Question, A1, A2, Correct");
  let answers = [A1,A2,A3,A4].filter(a=>a);
  if (new Set(answers).size !== answers.length) return alert("Duplicate answers");
  if (!/^[1-4](,[1-4])*$/.test(correct)) return alert("Correct answers must be 1-4");
  return true;
}

// CRUD functions
function addQuestion() {
  if (editingIndex!==null) return alert("Editing active");
  let q=document.getElementById("question").value.trim();
  let A1=document.getElementById("A1").value.trim();
  let A2=document.getElementById("A2").value.trim();
  let A3=document.getElementById("A3").value.trim();
  let A4=document.getElementById("A4").value.trim();
  let correct=document.getElementById("correct").value.trim();
  if(!validateInputs(q,A1,A2,A3,A4,correct)) return;
  pushUndo();
  dataList.push([q,A1,A2,A3,A4,"300",correct]);
  renderTable();
  clearInputs();
}

function renderTable() {
  const tbody=document.querySelector("#questionTable tbody");
  tbody.innerHTML="";
  dataList.forEach((row,index)=>{
    const tr=document.createElement("tr");
    tr.innerHTML=`<td>${index+1}</td><td>${row[0]}</td><td>${row[1]}</td><td>${row[2]}</td><td>${row[3]}</td><td>${row[4]}</td><td>${row[5]}</td><td>${row[6]}</td>
    <td><button class="delete" onclick="deleteQuestion(${index});event.stopPropagation();">Delete</button></td>`;
    tr.onclick=()=>editQuestion(index);
    tbody.appendChild(tr);
  });
}

function clearInputs() { ["question","A1","A2","A3","A4","correct"].forEach(id=>document.getElementById(id).value=""); editingIndex=null; }
function deleteQuestion(idx){ pushUndo(); dataList.splice(idx,1); renderTable(); clearInputs(); }
function editQuestion(idx){ editingIndex=idx; const row=dataList[idx]; ["question","A1","A2","A3","A4"].forEach((id,i)=>document.getElementById(id).value=row[i]); document.getElementById("correct").value=row[6]; }
function saveEdit(){ if(editingIndex===null) return alert("No question edited"); let q=document.getElementById("question").value.trim(),A1=document.getElementById("A1").value.trim(),A2=document.getElementById("A2").value.trim(),A3=document.getElementById("A3").value.trim(),A4=document.getElementById("A4").value.trim(),correct=document.getElementById("correct").value.trim(); if(!validateInputs(q,A1,A2,A3,A4,correct)) return; pushUndo(); dataList[editingIndex]=[q,A1,A2,A3,A4,"300",correct]; renderTable(); clearInputs(); }
function cancelEdit(){ clearInputs(); }
</script>
</body>
</html>
